--[[
    LAMA - Location Aware Movement API - 2013 Sangar

    This program is licensed under the Creative Commons BY-SA 3.0 license.
    http://creativecommons.org/licenses/by-sa/3.0/
]]
local a="/.lama-state"local b="/.lama-startup-backup"if not turtle then error("Can only run on turtles.")end;if not os.getComputerLabel()then error("Turtle has no label, required for state persistence.")end;if turtle.getFuelLevel()=="unlimited"then error("Turtles must use fuel for this API to work correctly.")end;local c={position={x=0,y=0,z=0,f=0},moving=false,preMoveFuel=0,tries=0,aggressive=false}local private={}version="1.0"side={forward=0,right=1,back=2,left=3,north=0,east=1,south=2,west=3,front=0}reason={unknown="unknown",queue_full="queue_full",coroutine="coroutine",fuel="fuel",block="block",turtle="turtle",unbreakable_block="unbreakable_block",entity="entity",invulnerable_entity="invulnerable_entity"}setmetatable(side,{__index=function(d,e)error("Trying to access invalid 'side' constant '"..e.."'.")end,__newindex=function()error("Trying to modify readonly table.")end})setmetatable(reason,{__index=function(d,e)error("Trying to access invalid 'reason' constant '"..e.."'.")end,__newindex=function()error("Trying to modify readonly table.")end})function forward(tries,aggressive)if c.moving then return false,reason.coroutine end;return private.move("forward",tries,aggressive)end;function back(tries)if c.moving then return false,reason.coroutine end;return private.move("back",tries)end;function up(tries,aggressive)if c.moving then return false,reason.coroutine end;return private.move("up",tries,aggressive)end;function down(tries,aggressive)if c.moving then return false,reason.coroutine end;return private.move("down",tries,aggressive)end;function turnRight()local g=turtle.native.turnRight()if g>=0 then c.position.f=(c.position.f+1)%4;private.save()return private.waitForResponse(g)end;return false end;function turnLeft()local g=turtle.native.turnLeft()if g>=0 then c.position.f=(c.position.f-1)%4;private.save()return private.waitForResponse(g)end;return false end;function turnAround()return turn(c.position.f+2)end;function turn(h)h=h%4;local i={}while c.position.f~=h do local g;if h==(c.position.f+1)%4 then g=turtle.native.turnRight()if g>=0 then c.position.f=(c.position.f+1)%4 else return false end else g=turtle.native.turnLeft()if g>=0 then c.position.f=(c.position.f-1)%4 else return false end end;private.save()table.insert(i,g)end;return private.waitForResponse(i)end;function get()local position=c.position;return position.x,position.y,position.z,position.f end;function getX()return c.position.x end;function getY()return c.position.y end;function getZ()return c.position.z end;function getPosition()local position=c.position;return vector.new(position.x,position.y,position.z)end;function getFacing()return c.position.f end;function set(x,y,z,f)local position=c.position;position.x=tonumber(x or position.x)position.y=tonumber(y or position.x)position.z=tonumber(z or position.x)position.f=tonumber(f or position.f)%4;private.save()return get()end;function startupResult()if not private.startupResult then return true end;return private.startupResult.result,private.startupResult.reason end;function hijackTurtleAPI(j)if j then if not turtle.__lama then return end;turtle.forward=turtle.__lama.forward;turtle.back=turtle.__lama.back;turtle.up=turtle.__lama.up;turtle.down=turtle.__lama.down;turtle.turnRight=turtle.__lama.turnRight;turtle.turnLeft=turtle.__lama.turnLeft;turtle.__lama=nil else if turtle.__lama then return end;turtle.__lama={forward=turtle.forward,back=turtle.back,up=turtle.up,down=turtle.down,turnRight=turtle.turnRight,turnLeft=turtle.turnLeft}turtle.forward=function()return forward()~=false end;turtle.back=function()return back()~=false end;turtle.up=function()return up()~=false end;turtle.down=function()return down()~=false end;turtle.turnRight=turnRight;turtle.turnLeft=turnLeft end end;function private.save()local d=textutils.serialize(c)local f=fs.open(a,"w")f.write(d)f.close()end;function private.load()if not fs.exists(a)or fs.isDir(a)then return end;local f=fs.open(a,"r")local d=f.readLine()f.close()local k=textutils.unserialize(d)if not type(k.position)=="table"or not type(k.position.x=="number")or not type(k.position.y=="number")or not type(k.position.z=="number")or not type(k.position.f=="number")or not(type(k.moving)=="boolean"or type(k.moving)=="string")or not type(k.preMoveFuel)=="number"or not type(k.tries)=="number"then print("LAMA: Invalid state file, deleting and ignoring it.")fs.delete(a)else c=k end end;local l={default={wrap=function()local m=fs.exists("/startup")if m then fs.move("/startup",b)end;local f=fs.open("/startup","w")f.writeLine("os.loadAPI('lama')")if m then f.writeLine("shell.run('/startup')")else end;f.close()end,unwrap=function()fs.delete("/startup")if fs.exists(b)then fs.move(b,"/startup")end end},forairan={init=function()if not fs.exists("/init-scripts/00_lama")then local f=fs.open("/init-scripts/00_lama","w")f.write("os.loadAPI('lama')")f.close()end end}}if fs.exists("/init-scripts")and fs.isDir("/init-scripts")then private.startupHandler=l.forairan else private.startupHandler=l.default end;if private.startupHandler.init then private.startupHandler.init()end;function private.wrapStartup()if private.isStartupWrapped then return end;private.isStartupWrapped=true;if private.startupHandler.wrap then private.startupHandler.wrap()end end;function private.unwrapStartup(n)if not private.isStartupWrapped and not n then return end;private.isStartupWrapped=false;if private.startupHandler.unwrap then private.startupHandler.unwrap()end end;function private.waitForResponse(i)if type(i)~="table"then i={i}elseif#i==0 then return true end;local o=true;repeat local p,q,result=os.pullEvent("turtle_response")if p=="turtle_response"then for r=1,#i do if i[r]==q then o=o and result;table.remove(i,r)break end end end until#i==0;return o end;function private.tryGetReason(s)local detect=({forward=turtle.detect,up=turtle.detectUp,down=turtle.detectDown})[s]local side=({forward="front",up="top",down="bottom"})[s]if detect then if detect()then if peripheral.isPresent(side)and peripheral.getType(side)=="turtle"then return reason.turtle else return reason.block end else return reason.entity end end;return reason.unknown end;function private.move(s,tries,aggressive)if turtle.getFuelLevel()<1 then return false,reason.fuel end;tries=tonumber(tries or 0)local move=({forward=turtle.native.forward,back=turtle.native.back,up=turtle.native.up,down=turtle.native.down})[s]local detect=({forward=turtle.detect,up=turtle.detectUp,down=turtle.detectDown})[s]local dig=({forward=turtle.dig,up=turtle.digUp,down=turtle.digDown})[s]local attack=({forward=turtle.attack,up=turtle.attackUp,down=turtle.attackDown})[s]local side=({forward="front",up="top",down="bottom"})[s]local o;while true do c.preMoveFuel=turtle.getFuelLevel()local t=move()if t<0 then c.preMoveFuel=0;private.unwrapStartup()return false,reason.queue_full end;c.moving=s;c.tries=tries;c.aggressive=aggressive;private.save()private.wrapStartup()o=private.waitForResponse(t)private.updateState(o,o)if not o and tries>0 then if detect and detect()then if peripheral.isPresent(side)and peripheral.getType(side)=="turtle"then os.sleep(2)elseif dig and not dig()and tries==1 then private.unwrapStartup()return false,reason.unbreakable_block end elseif aggressive and attack and not attack()and tries==1 then private.unwrapStartup()return false,reason.invulnerable_entity else os.sleep(1)end;tries=tries-1;os.sleep(0.5)else break end end;private.unwrapStartup()if o then return true else return false,private.tryGetReason(s)end end;function private.updateState(o,u)if o then local position,s=c.position,c.moving;local v={forward={1,0,0},right={0,1,0},back={-1,0,0},left={0,-1,0},up={0,0,1},down={0,0,-1}}for r=1,position.f do v.forward,v.right,v.back,v.left=v.right,v.back,v.left,v.forward end;position.x=position.x+v[s][1]position.y=position.y+v[s][2]position.z=position.z+v[s][3]end;if u then c.moving=false;c.preMoveFuel=0;c.tries=0;c.aggressive=false end;private.save()end;private.load()if not lama and c.moving then os.sleep(1)turtle.detect()private.unwrapStartup(true)if turtle.getFuelLevel()==c.preMoveFuel then if c.tries>0 then local result,w=private.move(c.moving,c.tries,c.aggressive)private.startupResult={result=result,reason=w}else private.startupResult={result=false,reason=private.tryGetReason(c.moving)}private.updateState(false,true)end elseif turtle.getFuelLevel()==c.preMoveFuel-1 then private.updateState(true,true)else fs.delete(a)error("Unexpected fuel state after reboot, probably invalid API use.")end end